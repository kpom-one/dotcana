# Effects and Triggers Architecture Design
# Design Date: 2025-12-23
# Purpose: Plan architecture for effects, triggers, and bag system before implementing challenge mechanic

## Core Principles

1. **Everything in the graph**: All game state lives in the graph
2. **Effects as nodes**: Modifiers and triggers are effect nodes with edges
3. **Bag as zone**: Triggered abilities wait in bag zone before resolving
4. **Stats are calculated**: Helper functions compute stats by walking effect edges

---

## Effect System

### Effect Node Structure

Effects are nodes in the graph with edges to source and targets:

```
source_card -> effect_node [label="GRANTS"]
effect_node -> target_card [label="APPLIES_TO"]
```

**Effect Node Attributes:**
- `type: "Effect"`
- `effect_type: str` - Type of effect (STRENGTH_MOD, RESIST, TRIGGER, etc.)
- `value: str` - Effect value ("+2", "1", etc.)
- `expires: str` - When effect expires ("end_of_turn", "start_of_next_turn", "never")
- Additional attributes based on effect_type

**Edge Types:**
- `GRANTS`: Points from source (card/ability) to effect node
  - Who created this effect (matters for removal/interaction)
- `APPLIES_TO`: Points from effect node to target(s)
  - Who is affected by this effect
  - Can have multiple targets ("all your characters")

### Effect Types

#### 1. Stat Modifiers
```yaml
effect_node:
  type: Effect
  effect_type: STR
  value: "+2"
  expires: end_of_turn

# Example: "Give target character +2 strength this turn"
action_card -> effect.strength_mod.123 [GRANTS]
effect.strength_mod.123 -> target_card [APPLIES_TO]
```

#### 2. Resist (Damage Reduction)
```yaml
effect_node:
  type: Effect
  effect_type: RESIST
  value: "1"
  expires: never  # Static ability

# Example: Card with "Resist +1" enters play
card_node -> effect.resist.456 [GRANTS]
effect.resist.456 -> card_node [APPLIES_TO]
```

#### 3. Triggers
```yaml
effect_node:
  type: Effect
  effect_type: TRIGGER
  event: on_challenge
  action: deal_damage
  target_spec: challenger  # or defender, self, etc.
  value: "1"
  expires: never

# Example: "When this character is challenged, deal 1 damage to challenging character"
card_node -> effect.trigger.789 [GRANTS]
effect.trigger.789 -> card_node [APPLIES_TO]
```

### Static vs Dynamic Effects

**Static Effects** (from card abilities):
- Created when card enters play
- Removed when card leaves play
- `expires: never`
- Examples: Resist, Evasive, static stat bonuses

**Dynamic Effects** (from abilities/actions):
- Created during game by resolving abilities
- Have expiration conditions
  - end_of_turn
  - start_of_your_turn
- Examples: "Give +2 strength this turn"

---

## Stat Calculation

### Helper Functions (in cards.py)

```python
def get_strength(state, card_node) -> int:
    """Calculate effective strength: base + modifiers."""
    # 1. Get base from card DB
    # 2. Walk all APPLIES_TO edges pointing to card_node
    # 3. Sum all STRENGTH_MOD effects
    # 4. Return max(0, base + mods)

def get_willpower(state, card_node) -> int:
    """Calculate effective willpower: base + modifiers."""
    # Similar to get_strength
```

**Why in cards.py?**
- Already handles card database access
- Card stats naturally belong with card data
- Keeps stat logic centralized

---

## Trigger System

### Trigger Events

Triggers fire on specific game events:

```yaml
Events:
  - on_play              # When card enters play
  - on_challenge_start   # When challenge declared (before damage)
  - on_challenge_damage  # During damage step
  - on_damage_dealt      # After damage dealt
  - on_banished          # When card would be banished
  - on_quest             # When character quests
  - while_challenging    # Duration effect during challenge
  - while_being_challenged  # Duration effect while being challenged
```

### Trigger Resolution Flow

Per comp rules 8.7 (Bag system):

```
1. Event occurs
2. All matching triggers → bag (simultaneously)
3. Active player chooses one of their triggers
4. Resolve trigger completely
5. If new triggers fire, add to bag
6. Repeat until active player has no triggers
7. Next player resolves their triggers
8. Continue until bag empty
9. Proceed to next game step
```

**Key Points:**
- Triggers don't execute immediately - they queue in bag
- Active player gets priority
- Each trigger fully resolves before next
- New triggers from resolution go back to bag

---

## Bag System (Deferred Implementation)

### Bag as Zone

The bag is a conceptual zone (`z.bag`) that holds pending triggered abilities:

```yaml
# When trigger fires:
trigger_instance_node -> z.bag [label="IN"]

# Trigger instance attributes:
trigger_instance_node:
  type: TriggerInstance
  source_effect: effect.trigger.789  # Which trigger created this
  owner: p1                          # Whose trigger
  event: on_challenge                # What triggered it
  # Additional context data
```

**Game Flow with Bag:**
```python
# In compute_all():
if bag_has_triggers(G):
    # Only generate CAN_RESOLVE_TRIGGER edges
    # Player must resolve triggers before other actions
else:
    # Normal CAN_INK, CAN_PLAY, etc.
```

**Implementation Notes (for later):**
- Add `z.bag` zone in template
- Create trigger instance nodes when triggers fire
- Modify compute_all to check bag first
- Add resolution mechanic (CAN_RESOLVE_TRIGGER)
- Track whose turn to resolve (active player first)

---

## Challenge Mechanic Implementation Plan

### Phase 1: Basic Challenge (Now)

**Scope:**
- Challenge exerted characters
- Deal damage simultaneously
- Banish if damage >= willpower
- No triggers, no effects, no bag

**Files to create/modify:**
```
lib/lorcana/mechanics/challenge.py
  - compute_can_challenge(G)
  - execute_challenge(state, attacker, defender)

lib/lorcana/cards.py (add helpers)
  - get_strength(state, card_node)
  - get_willpower(state, card_node)

lib/lorcana/banish.py (new file for reusable logic)
  - check_and_banish(state, card_node)
```

**Challenge Flow (Simplified):**
```python
def execute_challenge(state, attacker, defender):
    # 1. Tap attacker
    state.graph.nodes[attacker]['tapped'] = '1'

    # 2. Get stats
    attacker_strength = get_strength(state, attacker)
    defender_strength = get_strength(state, defender)

    # 3. Deal damage (simultaneous)
    state.damage_card(defender, attacker_strength)
    state.damage_card(attacker, defender_strength)

    # 4. Check for banish (state-based action)
    check_and_banish(state, attacker)
    check_and_banish(state, defender)
```

### Phase 2: Add Effect System (Later)

**Scope:**
- Create effect nodes when cards enter play
- Implement get_strength/willpower with effect walking
- Add Resist support
- Add stat modifier effects

**New capability:**
- Cards with static abilities (Resist, Challenger)
- Dynamic buffs ("Give +2 strength this turn")

### Phase 3: Add Triggers and Bag (Later)

**Scope:**
- Implement bag zone
- Create trigger instances
- Add trigger resolution
- "While challenging" effects

**New capability:**
- Full challenge interaction
- Triggered abilities
- Complex interactions

---

## Open Questions

1. **Effect node IDs**: Use what format?
   - `effect.{type}.{source}` (e.g., `effect.resist.p1.tinkerbell.c`)

2. **Multiple targets**: How to handle "all your characters get +1"?
   - One effect node with multiple APPLIES_TO edges? 

3. **Effect expiration**: Who cleans up expired effects?
   - End-of-turn step checks all effects with `expires=end_of_turn`
   - This is probably done by the caller of compute edges, or around that
   - Remove effect node and edges

4. **Trigger ownership**: When card leaves play, remove its triggers?
   - Yes - walk GRANTS edges from card, remove effect nodes

---

## Decision Log

- ✅ Effects as nodes (not edges)
- ✅ GRANTS + APPLIES_TO edge pattern
- ✅ Stats helpers in cards.py
- ✅ Triggers as effect nodes with event attribute
- ✅ Bag as zone (deferred implementation)
- ✅ Phase 1: Basic challenge without effects/triggers
